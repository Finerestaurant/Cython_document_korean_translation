Cython은 파이썬 컴파일러 입니다. 그 말인 즉슨, 일반적인 파이썬 코드를 그대로 컴파일 할수 있다는 의미입니다(아직 지원되지 않는 일부 언어 기능에 대한 몇 가지 명백한 예외는 제외합니다. 자세한 사항은 [한계](한계링크) 참고). 그러나 성능이 중요한 코드에 있어서는 타입을 정적으로 선언하는 것은 꽤나 도움이 됩니다. Cython이 파이썬 코드의 동적 특성에서 벗어나 더 간단하고 빠른 C 코드를 생성할 수 있기 때문입니다 - 때로는 몇배나 빨라지기도 합니다.

하지만 유의해야할 점은, 타입 지정이 당신의 소스코드를 장황하게 하고 가독성을 떨어트리게 할수 있다는 점입니다. 따라서 타입 지정을 성능이 중요한 섹션에서 당신의 코드를 빠르게 만들 수 있다는 것을 벤치마크가 입증하는 경우와 같은 타당한 이유 없이 사용하는 것은 권장되지 않습니다. 일반적으로 적절한 곳에 사용되어질때 효과가 있습니다. 

정수와 부동소수점 타입, 복소수 타입, 구조체, 유니온과 포인터 타입과 같은 모든 C의 타입을 선언할수 있습니다. Cython은 타입을 목적에 맞도록 정확하게 알아서 변환시킵니다. 이것은 파이썬의 타입에서 C의 타입으로 변환할 때 값이 오버플로우되면서 런타임에 OverflowError가 발생하는 [임의 사이즈 정수 타입](https://peps.python.org/pep-0237/)을 포함합니다(그러나 산술 작업을 수행할 때는 오버플로우를 확인하지는 않습니다). 이 경우 생성된 C 코드는 플랫폼에 의존하는 C 타입의 크기를 정확하고 안전하게 처리합니다.

타입은 cdef 키워드를 통해서 선언됩니다.

## 변수 타입 지정하기

다음의 순수 Python 코드를 생각해보자.
```python
def f(x)
    return x ** 2 - x

def integrate_f(a, b, N):
    s = 0
    dx = (b - a) / N
    for i in range(N):
        s += f(a + i * dx)
    return s * dx
```
단순하게 이 코드를 Cython으로 컴파일 하면 거의 35%의 속도향상을 얻을수 있습니다. 없는 것보다는 낫지만, 몇개의 정적 타입을 추가하면 훨씬 더 큰 차이가 날 수 있습니다.

몇개의 타입 선언을 추가하면 다음과 같을 것입니다. 

```python
def f(double x):
    return x ** 2 - x
    
def integrate_f(double a, double b, int N):
    cdef int i
    cdef double s, dx
    s = 0
    dx = (b - a) / N
    for i in range(N):
        s += f(a + i * dx)
    return s * dx
```
이터레이터 변수 `i`가 C의 방식으로(semantic) 선언되었기 때문에, for 반복문은 순수한 C 코드로 컴파일 됩니다. `a`와 `s`, 그리고 `dx`의 타입을 선언하는 것도 산술과정에 for 반복문에 관여하기 때문에 중요합니다. `b`와 `N`의 타입을 선언하는 것은 덜 중요할수 있으나, 이 경우 일관성을 유지하고 전체 함수를 입력하는 것은 큰 추가 작업이 아닙니다.

이 경우에는 순수 파이썬 코드보다 4배나 빠른 속도 향상을 보여주었습니다.

## 함수 타입 지정하기
파이썬의 함수호출은 꽤나 비용이 많이 들며, 그 함수를 호출하기 위해 Python 개체로 변환하고 또 Cython으로 변환해야 하기 때문에 두배나 비용이 더 들수 있습니다. 위의 예시에서는 인자 주변에 생성되어져야 하는 파이썬 `float` 객체가 전달이 되기 전에, 인자는 f()내부와 f()에서 C double로 가정되어져서 호출되어지고 있습니다.

그러므로 Cython은 C 스타일의 함수를 선언할수 있는 문법인 cdef 키워드를 제공합니다.

```python
cdef double f(double x) except? -2:
    return x ** 2 - x
```

일반적으로는 except 수정자가 추가되어야 합니다. 그렇지 않으면 Cython은 함수 안에 있는 예외를 전달해주지 못할 것입니다. `except? -2`는 -2가 반환될 경우 오류가 확인 된다는 의미입니다(?는 -2가 유효한 반환 값으로 사용되고 있을수도 있음을 나타냅니다). 이와 달리 느린 `except *`는 항상 안전합니다. 함수에서 파이썬 객체를 반환하거나 함수 호출 내에서 예외가 발생하지 않을 것이 보장되는 경우 except 절을 생략할 수 있습니다.

`cdef`의 부작용은 파이썬이 호출하는 방법을 모르기 때문에 이 함수를 파이썬 space에서 더 이상 사용할 수 없다는 것입니다. 더이상 런타임에서 f()를 변경할수 없게 됩니다. 

`cdef` 대신 `cpdef`를 사용하게 되면 파이썬 래퍼(wrapper)도 생성되므로 Cython(빠르고, 타입 지정된 값을 직접 전달함)과 파이썬(파이썬 객체로 값을 래핑(wrapper)함) 모두에서 함수를 사용할 수 있습니다. 사실 `cpdef`는 단순히 파이썬 래퍼만 제공하는 것이 아니라 Cython 내에서 호출된 경우에도 파이썬 메서드에 의해서 메서드를 재정의 할수 있는 로직도 설치합니다. 이 경우 `cdef`메서드에 비해 약간의 오버헤드가 추가됩니다. 

속도향상: 순수 파이썬 대비 150배

## 타입을 추가할 위치 결정하기

정적 타입 지정은 많은 경우에서 큰 속도 향상을 얻기 때문에, 초보자들은 종종 눈에 보이는 모든 것에 타입을 지정하는 경향이 있습니다. 이렇게 하게 되면 가독성과 유연성 모두 저하되고 속도까지 느려지게 됩니다(예: 불필요한 타입 체크, 변환, 느린 버퍼 해제). 다른 한편으로는 중요한 루프의 변수의 타입을 지정하는 것을 잊어버리면 성능이 저하되기 쉽습니다. 이 작업에 도움이 되는 두 필수적인 툴은 profiling과 annotation입니다. 최적화의 첫 번째 단계는 profiling이 되어야 하며, 당신의 코드가 어디에서 시간이 사용되고 있는지 알수 있습니다. 그러면 Cython의 annotation을 통해 코드가 시간이 걸리는 이유를 알 수 있습니다. 

`cython`의 커맨드 라인 프로그램으로 `-a`를 사용하면, 생성된 C 코드와 인터리브된 Cython 코드의 결과로 HTML 보고서가 생성됩니다. 라인들은 "타입 지정(typedness)" 수준에 따라서 색이 지정 됩니다. 흰색 라인은 순수한 C로 변환될수 있고, 파이썬의 C-API가 필요한 라인들은 노란색입니다(C-API의 상호 작용으로 변환될수록 더 어두워집니다). C 코드로 변환되는 행은 앞에 (+)가 있으며, 클릭 하여서 생성된 코드를 볼수 있습니다. 

이 보고서는 속도를 위해 함수를 최적화하고 GIL을 해제하는 시기를 결정할 때 매우 유용합니다. 일반적으로 nogil 블록에는 "흰색" 코드만 포함됩니다.

![](https://cython.readthedocs.io/en/stable/_images/htmlreport.png)

Cython은 할당(루프 변수 대상 포함)을 기반으로 로컬 변수의 타입을 추론하므로 모든 곳에서 타입을 명시적으로 지정해야 하는 필요성도 줄일 수 있습니다. 예를 들어서, `dx`를 위의 double 타입으로 선언하는 것은 마지막 버전에서 `s` 타입을 선언하는 것과 마찬가지로 불필요합니다(`f`의 반환 타입은 C double인 지점.) 그러나, Cython은 오버플로가 발생하지 않도록 보장할 수 없기 때문에, *산술식에 사용되는 정수형*도 주의해야할 예외입니다(따라서 파이썬의 [bignum](https://peps.python.org/pep-0237/)이 필요할 경우 객체로 돌아갑니다). C 정수 타입의 추론을 허용하려면 `infer_types` 지시문을 `True`로 설정해야 합니다. 이 지시문은 파이썬에 익숙한 독자들을 위해서 C++의 `auto`키워드와 비슷한 역할을 합니다. 모든 것의 타입을 지정해야 하는 필요성을 줄이는 것은 큰 도움이 될 수 있지만, 놀라움으로 이어질 수도 있습니다. 특히 C타입의 산술적 표현에 익숙하지 않다면 더욱 그렇습니다. 이러한 항목에 대한 간단한 개요는 [여기](https://www.eskimo.com/~scs/cclass/int/sx4cb.html)에서 확인할 수 있습니다.